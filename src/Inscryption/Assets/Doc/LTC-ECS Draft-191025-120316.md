ECS Draft üö´ Beginner mistakes Using inheritance for components and
using interfaces is a very common beginner mistake. Why is it bad for
development? No benefit. Abstraction at the component level gives you no
real gain compared to ECS-style abstraction through data (I ºll cover
that next). Adds limits. It makes components harder to extend and the
related logic harder to improve. Leads to logic in components. You start
putting behavior inside a component, which breaks ECS rules. Creates
extra complexity. You feel forced to inherit systems or write big
switch/case blocks by type for no good reason. One note: inheriting
systems is not always a good idea, but it ºs not harmful by itself,
unlike inheriting components. So if you feel the urge to inherit
components - don ºt. Stop and think of another way to solve the problem.
Not using ECS-style abstraction. ECS abstraction means we put shared
data (the stuff you ºd "inherit" in OOP) into a separate component. How
to make a "child" of that data? Simple: keep the BaseComponent with the
shared fields, add a new InheritorComponent with the extra fields you
need, filter entities that have both BaseComponent and
InheritorComponent. That ºs it. If you notice common data across
components or entities, you can almost always move it into its own
component - and the earlier you do it, the better. One of the most
flexible ways to design components is the atomic component approach. In
this style, each component has only one field. It takes practice to
master, but once you do, it gives you a very flexible way to write code.
Example: 1// ‚ùå BAD 2\[Game\] 3publicsealedclassCharacter:IComponent 4{
5 publicVector3 position; 6 publicVector2 inputDir; 7 publicfloat
moveSpeed; 8 publicbool isFrozen; 9 publicbool isSprinting; 10} 11 12//
‚úÖ GOOD 13\[Game\]publicclassPosition:IComponent{publicVector3 Value;}
14\[Game\]publicclassMoveDirection:IComponent{publicVector2 Value; }
15\[Game\]publicclassMoveSpeed:IComponent{publicfloat Value;} 16 17//
Tag components (no fields) 18\[Game\]publicclassFrozen:IComponent{}//
presence = frozen 19\[Game\]publicclassCharacter:IComponent{}
20\[Game\]publicclassSprinting:IComponent{}

Turning ECS into an absolute Only Sith deal in absolutes! Remember: OOP
is not forbidden. Using a hybrid of OOP and ECS is a common practice.
When you work with ECS, don ºt push everything into it. That can be
counterproductive. Some data structures don ºt map well to ECS. In those
cases don ºt stress - just write a separate OOP class. You can build
certain parts (for example UI) outside of ECS in whatever way is
comfortable, and then connect them to ECS with a small bridge. Also,
helper tasks - loading configs, direct network calls, writing saves are
often easier as OOP services that systems call directly, instead of
forcing them into ECS. Use common sense. ECS should help your
development, not get in the way. Trying to port existing code to ECS
word for word Beginners often try to move their existing code to ECS
line by line. That ºs not a good idea, because coding in ECS is different
from traditional programming. The usual result is frustration with ECS
and a very awkward codebase. If you do need to move old code to ECS, the
best way is to rewrite the logic from scratch in ECS. Use your knowledge
and the old code as a guide for what the feature should do not as
something to copy. Using delegates/callbacks or reactive logic inside
systems In ECS it can be risky to capture system logic and store it in a
component for later, or to react immediately to changes (for example,
one system reacting the moment another adds a component). This adds
tight coupling between systems - they start to depend on outside calls
and it breaks the clean data-processing pipeline by adding logic that we
don ºt fully control when it runs. A better option is to use deferred
reactivity, which I ºll explain in . Sorting files by type When you start
with ECS it ºs tempting to sort files by type: put components in a
Components folder and systems in a Systems folder. With experience, you
see this is not very effective. It ºs hard to navigate and hard to see
which components relate to which systems. A better way is feature-based
folders. Put everything for one feature in one folder (you can keep a
small inner split like components/systems). For example, all components
and systems for health and damage go in a Health folder. This lets you
see the main context of the data and systems at a glance and makes the
project easier to navigate. ‚úÖ Best Practices Tagging entities with
marker components In ECS a "marker component" (aka "tag component") is a
component with no fields. It ºs only job is to mark an entity. You can
think of it like a boolean flag on a class: it ºs either present (true)
or absent (false). Example: you have a bunch of units, and one of them
is controlled by a player. You can mark that unit with an empty Player
component. This lets you filter for player units and also lets you tell
while iterating over all units whether you ºre dealing with a regular
unit or the player-controlled one.Best Practices

Minimize places where a component is changed The fewer places change a
component the better. This follows the very useful Don ºt Repeat Yourself
(DRY) principle. It has many benefits. 1. You understand data changes
more clearly across the project, which makes debugging easier when
something goes wrong. 2. When you update the logic for changing data you
touch less code - ideally only one place. 3. There ºs a lower chance of
data bugs appearing out of nowhere. Example: instead of modifying Health
component in every system that deals damage, create a single
DamageSystem whose job is to apply damage to entities with
HealthComponent. Damage itself also can be an entity with a
DealDamageRequest component on it. Use the "Component" suffix only when
it helps The "Component" suffix is useful for beginners because it
reminds you "this is data only." Over time, you don ºt need that
reminder, but your code stays noisy with "Component" everywhere. My
advice: you can safely drop the suffix - it adds little value, aside
from maybe making autocomplete/IntelliSense searches a bit easier. For
example, CurrentHealthComponent becomes just CurrentHealth and the code
reads a bit more fluently: entity.hasCurrentHealth. However sometimes
you want to store a reference to a MonoBehaviour inside an ECS
component, and you ºll likely want to name that component the same as the
Unity-side type. To avoid name conflicts in that case, you should add
the word "Component" to the ECS component ºs name, like this: Storing a
reference to another entity inside a component You might be wondering:
"How do we link entities in ECS? Do we tag them with components and then
search in a loop?" Of course not. It ºs much simpler: we store a
reference - just in a different form. We create a separate ID component:
Attach this component to every new entity: Now every entity in the game
has a unique ID. When we want to point to another entity, we don ºt store
a reference to its component or to GameEntity itself. We store its id.
This keeps links simple, serializable and easy to look up.
1\[Game\]publicclassEnemyViewComponent:IComponent{publicEnemyView
Value;}
1\[Game\]publicclassId:IComponent{\[PrimaryEntityIndex\]publicint
Value;} 1CreateEntity.Empty() 2.AddId(\_idService.Next()) 3// add other
components... 4;

Deferred reactivity and one-frame components As noted in "Beginner
mistakes" reactive code in ECS can cause problems. But in game dev you
often need to react to events. The answer is deferred reactivity.
Deferred reactivity means: instead of calling logic right away when the
event happens, you write data that says the event happened. Any system
that cares will react to that data at the right time for it. Think of it
like an OOP "dirty" flag: anyone can set SetDirty(true), but the logic
reads and handles it later. Let ºs say Health component changes, the
entity gets a HealthChangedmarker component added. Such markers live for
one frame: they notify systems this frame, then get removed so the logic
doesn ºt repeat next frame. The component can be removed by the system
that adds it, or by a separate cleanup system that clears all X markers
where you need it. Example: we have a DealDamageByRequestSystem. To tell
it how much damage to apply, we add a DealDamageRequest component with
the damage amount and the ID of the target entity.
DealDamageByRequestSystem iterates entities with Health and
DealDamageRequest, finds the target by ID, applies damage, removes
DealDamageRequest, and adds a WasDamaged marker to the target. That
marker lets later systems know the entity took damage. At the end of the
frame, a cleanup system removes WasDamaged so it won ºt be processed
again next frame. 1publicclassDealDamageByRequestSystem:IExecuteSystem
2{ 3 privatereadonlyGameContext \_game; 4
privatereadonlyIGroup`<GameEntity>`{=html} \_requests; 5
privatereadonlyIGroup`<GameEntity>`{=html} \_targets; 6 7
publicDealDamageByRequestSystem(GameContext game) 8{ 9 \_game = game; 10
11 \_requests = game.GetGroup(GameMatcher 12 .AllOf( 13
GameMatcher.DealDamageRequest)); 14 15 \_targets =
game.GetGroup(GameMatcher 16 .AllOf( 17 GameMatcher.Id, 18
GameMatcher.CurrentHP, 19 GameMatcher.Alive) 20 .NoneOf( 21
GameMatcher.Dead)); 22} 23 24 publicvoidExecute() 25{ 26
foreach(GameEntity request in \_requests) 27 { 28 GameEntity target =
\_game.GetEntityWithId(request.TargetId); 29 30
if(\_targets.ContainsEntity(target)) 31 { 32 float newCurrentHp =
target.CurrentHP - request.DamageAmount; 33 newCurrentHp =
Mathf.Clamp(newCurrentHp,0, target.hasMaxHP ? target.MaxHP :
newCurrentHp); 34 target.WasDamaged =true; 35 } 36 37
request.isDestructed =true;

Requests/Events as a systems API Building on one-frame components, we
can use them to express a simple API for systems: Request components to
ask a system to do work, and Event components to tell everyone what
happened. The system can control both lifecycles: delete Requests right
after handling them, and clear Events before firing new ones. This way
your features can "speak" to each other and still be completely
decoupled. Example: take the DealDamageByRequestSystem from the previous
section. We send a damage request with a DealDamageRequest component.
Same way we can notify others with a DamagedEntityEvent component on a
new event entity. The system ºs flow is: 1. Clear all DamagedEntityEvent
from the last frame (so the event makes a full loop through systems). 2.
For each entity with a request, apply damage. 3. Remove the request 4.
Create new entity and add DamagedEntityEvent on it. Extracting repeated
logic into DI services/extensions Over time you ºll notice you repeat the
same logic in different systems. Usually, that ºs a sign it ºs time to
make a new system :D But sometimes the repeated logic is helper code
tied to one or two specific components/entities and its result is used
for different purposes, for example a special way to read data from a
component. Some developers put such helper logic right inside the
component (like getters), but we are cool guys and we want to keep ECS
clean so I suggest another route: DI services or extension methods that
systems call. Example: you have a Team component that stores the team ºs
color. You might need to check in multiple systems whether two entities
are on the same team. Create a static TeamExtensions class with a method
IsInSameTeam(GameEntity, GameEntity) and put the shared comparison logic
there. This keeps components as data only and avoids duplication. Same
applies for the DI services. Let ºs say you have a complex logic of
checking wether an enemy is owning a specific type of a weapon. This
logic may require you to acces other DI services even, so in this case
it ºs better to be moved into a EnemyUtilsService DI service. This way
you can inject any other dependency for this logic. Grouping systems by
when they run As you know, system order matters in ECS, so it ºs useful
to group systems at the top level by their place in the frame. For
example, first you can run all input-related systems (InputFeature) to
collect user input and convert it to ECS data. Next comes the gameplay
group (GameplayCoreFeature), which interprets the input and updates the
ECS world. Finally, you run a cleanup group (GameCleanupFeature) that
should execute after all gameplay logic. Should you split
components/systems into small pieces? 38 } 39} 40}

This is a tricky question. Simple answer is: Yes - split. In 99% of
cases you won ºt regret about it. As said earlier, this is the "atomic"
style. The extreme form is: each component has only one field. This
gives you maximum composition in the project, reduces refactors, and
removes the "how do I combine entities with property X?" problem.
Downsides: The number of components grows fast, which can cause
confusion on large projects if you don ºt organize things well. It ºs
harder to "see" what an entity is from many small components (you can
fix this with a clear marker/tag component). When you can skip
splitting: events and requests. In the DealDamageOnRequestSystem
example, the DealDamageRequest component has several fields, because the
handling system usually needs all of them at once. I wouldn ºt call this
a strict rule, though. You might later wish you had split a request into
several components, but for requests/events it ºs often fine to keep them
together. If you don ºt split components, you ºll hit these problems: More
time to reach an ECS-friendly shape. If a designer adds a new entity
with similar data and you need to split later, the refactor cost grows
with the amount of code already tied to that data. Less freedom when
building entities. With many small components, you assemble entities
like LEGO from small behavior pieces. With fat components, you lose that
flexibility. How to assemble an Entity? It ºs very convenient to build
entities using the Factory pattern. Especially if you follow the atomic
component style. This way you can always check what components a given
entity has. If the entity needs new components you don ºt have to hunt
through many creation sites. You just open one Factory class and adjust
what you need. 1publicclassHeroFactory:IHeroFactory 2{ 3
privatereadonlyIIdentifierService \_identifiers; 4
privatereadonlyIConfigsService \_configs; 5 6
publicHeroFactory(IIdentifierService identifiers,IConfigsService
configs) 7{ 8 \_identifiers = identifiers; 9 \_configs = configs; 10} 11
12 publicGameEntityCreateHero() 13{ 14 HeroConfig config =
\_configs.GetHeroConfig(); 15 16 return CreateEntity.Empty() 17
.AddId(\_identifiers.Next()) 18 .With(x =\> x.isHero =true) 19 20
.AddLevel(1) 21 .AddExperience(0) 22 23
.AddMovementSpeed(config.MovementSpeed) 24 .With(x =\>
x.isTransformMovement =true)

How to store components? As said before it ºs better to split your logic
in features. Then components related to this feature can be put in a
single file inside this feature folder. For example we have
InventoryFeature. Folder structure would look like this: So all the
inventory components would go in InventoryComponents.cs: 25 26
.AddCurrentHealth(config.Health) 27 .AddMaxHealth(config.Health); 28}
29} 1Inventory 2- Systems 3- Services 4- InventoryFeature.cs 5-
InventoryComponents.cs 1usingSystem.Collections.Generic; 2usingEntitas;
3 4namespaceCode.Gameplay.Features.Loot.ItemDrop.Inventory 5{
6\[Game,Watched\]publicclassInventoryComponent:IComponent{
publicDictionary\<ItemTypeId,int\> Value;} 7 8\[Game\] 9
publicclassLoseItemInInventoryRequest:IComponent 10{ 11 publicint
TargetId; 12 publicItemTypeId TypeId; 13 publicint Amount; 14} 15
16\[Game\] 17 publicclassAddItemInInventoryRequest:IComponent 18{ 19
publicint TargetId; 20 publicItemTypeId TypeId; 21 publicint Amount; 22}
23}
